<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Runner Game - Mobile Fix & Fast Jump</title>

<style>
    /* 폰트 설정 */
    @font-face {
        font-family: 'NeoDonggeunmo';
        src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.3/NeoDunggeunmo.woff') format('woff');
        font-weight: normal;
        font-display: swap;
    }

    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'NeoDonggeunmo', sans-serif;
    }

    #game-container {
        position: relative;
        width: 800px;
        height: 300px;
        background: #333;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    #player-gif {
        position: absolute;
        z-index: 10;
        width: 40px;
        height: 40px;
        top: 0;
        left: 0;
        will-change: transform;
        display: none;
    }

    .ui-btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        border: none;
        background: transparent;
        padding: 0;
        cursor: pointer;
        display: none;
        z-index: 99; /* 캔버스보다 위에 오도록 */
        width: 200px; 
        height: auto; 
        /* 모바일 터치 영역 확보를 위해 터치 액션 설정 */
        touch-action: manipulation;
    }

    #restartBtn { top: 50%; }
    #clearBtn { top: 60%; }

</style>
</head>
<body>

<div id="game-container">
    <img id="player-gif" src="src/game/cha.gif" alt="Player">

    <img id="restartBtn" class="ui-btn" src="src/ui/restart_btn.png" alt="다시 시작">
    <img id="clearBtn" class="ui-btn" src="src/ui/clear_btn.png" alt="종강이다!">

    <canvas id="game" width="800" height="300"></canvas>
</div>

<script>
const container = document.getElementById("game-container");
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const playerEl = document.getElementById("player-gif");
const restartBtn = document.getElementById("restartBtn");
const clearBtn = document.getElementById("clearBtn");
let isMobile = ('ontouchstart' in window);

function resizeGame() {
    const gameWidth = 800;
    const gameHeight = 300;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    const scaleX = windowWidth / gameWidth;
    const scaleY = windowHeight / gameHeight;
    const scale = Math.min(scaleX, scaleY);

    container.style.transform = `scale(${scale})`;
}
window.addEventListener('resize', resizeGame);
resizeGame();

ctx.imageSmoothingEnabled = false;

if (!ctx.roundRect) {
    ctx.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
    };
}

let coffeeImg = new Image(); coffeeImg.src = "src/game/coffee.png"; 
let bgImg = new Image(); bgImg.src = "src/game/bg.png"; 

const obstacleSources = [
    "src/game/obstacle1.png", 
    "src/game/obstacle2.png", 
    "src/game/obstacle3.png" 
];
const obstacleImages = obstacleSources.map(src => {
    const img = new Image();
    img.src = src;
    return img;
});

function drawImageAuto(img, x, y, w, h, fallbackColor) {
    if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, w, h);
    } else {
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(x, y, w, h);
    }
}

let gameState = "play";
let player, bg, obstacles, coffees;
let frame, playerDistance, nextPatternDistance;

const obstacleTypes = [
    { width: 70, height: 70 }, 
    { width: 70, height: 70 },
    { width: 70, height: 70 }
];
const obstacleHeights = [260, 210];

function initGame() {
    // [수정됨] 웹(PC)에서는 부드럽게, 모바일에서는 묵직하게 분기 처리
    // isMobile ? 모바일값 : 웹값
    
    player = {
        x: 80,
        y: 200,
        width: 60, 
        height: 60,
        vy: 0,
        
        // 웹: 0.8 (부드러움) / 모바일: 1.5 (묵직함)
        gravity: isMobile ? 1.5 : 0.8,    
        
        // 웹: -16 (적당함) / 모바일: -22 (강함)
        // 중력을 낮추면 점프력도 낮춰야 화면 밖으로 나가지 않습니다.
        jumpPower: isMobile ? -22 : -16,  
        
        jumpCount: 0,
        speed: isMobile ? 11 : 8, // 웹에서는 속도도 6->8로 살짝 올려야 지루하지 않음
        hp: 3 
    };

    bg = { x: 0, width: 8700, height: 300 };
    
    obstacles = [];
    coffees = [];
    frame = 0;
    playerDistance = 0;
    nextPatternDistance = 500;
    
    playerEl.style.display = "block";
    gameState = "play";
    restartBtn.style.display = "none";
    clearBtn.style.display = "none";
}
initGame();

function doJump() {
    if (gameState !== "play") return;
    if (player.jumpCount < 2) {
        player.vy = player.jumpPower;
        player.jumpCount++;
    }
}

// [수정됨] 모바일 터치 이벤트 핸들러 수정
document.body.addEventListener("touchstart", e => { 
    // 터치된 요소(target)가 버튼(.ui-btn)이면 기본 동작 허용(클릭)하고 점프하지 않음
    if (e.target.classList.contains('ui-btn')) {
        return; 
    }

    // 그 외(게임 화면)를 터치했을 때만 스크롤 방지 및 점프
    e.preventDefault(); 
    doJump(); 
}, { passive: false });

document.body.addEventListener("mousedown", (e) => {
    if (e.target.classList.contains('ui-btn')) return;
    doJump();
});

window.addEventListener("keydown", e => { if (e.code === "Space") doJump(); });

function spawnObstacle(offset = 0, h = "random") {
    const t = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    let yBase = h === "random" ? obstacleHeights[Math.floor(Math.random() * obstacleHeights.length)] : h;
    const randomImg = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];

    // 랜덤 각도 고정
    const randomAngle = Math.random() * Math.PI * 2;

    obstacles.push({ 
        x: canvas.width + offset + 50, 
        y: yBase - t.height, 
        width: t.width, 
        height: t.height,
        img: randomImg,
        angle: randomAngle
    });
}

function spawnPattern() {
    const p = Math.floor(Math.random() * 4);
    if (p === 0) spawnObstacle(0, "random");
    if (p === 1) { spawnObstacle(0, 260); spawnObstacle(200, 260); }
    if (p === 2) spawnObstacle(0, 210);
    if (p === 3) { spawnObstacle(0, 260); spawnObstacle(250, 210); }
    
    nextPatternDistance = playerDistance + 600 + Math.random() * 300;
}

function spawnCoffee() {
    coffees.push({ 
        x: canvas.width + 50, 
        y: 150, 
        width: 40, 
        height: 58
    });
}

function collide(player, target) {
    const marginX = 20; 
    const marginY = 15; 

    return (
        player.x + marginX < target.x + target.width - marginX &&
        player.x + player.width - marginX > target.x + marginX &&
        player.y + marginY < target.y + target.height - marginY &&
        player.y + player.height - marginY > target.y + marginY
    );
}

function updateGame() {
    if (gameState !== "play") return;

    let isEndingPhase = (bg.x + bg.width <= canvas.width);

    if (!isEndingPhase) {
        bg.x -= player.speed * 0.3;

        obstacles.forEach(o => {
            o.x -= player.speed;
        });
        
        coffees.forEach(c => c.x -= player.speed);

        playerDistance += player.speed;
        if (playerDistance >= nextPatternDistance) spawnPattern();
        if (frame % 400 === 0) spawnCoffee();
    } else {
        player.x += player.speed;
        if (player.x >= (canvas.width / 2) - (player.width / 2)) {
            gameState = "clear";
            clearBtn.style.display = "block"; 
            return;
        }
    }

    // 물리 엔진
    player.vy += player.gravity;
    player.y += player.vy;
    if (player.y >= 260 - player.height) {
        player.y = 260 - player.height;
        player.vy = 0;
        player.jumpCount = 0;
    }
    
    playerEl.style.transform = `translate(${player.x}px, ${player.y}px)`;
    playerEl.style.width = player.width + "px";
    playerEl.style.height = player.height + "px";

    obstacles = obstacles.filter(o => {
        if (collide(player, o)) {
            player.hp--;
            if (player.hp <= 0) { 
                gameState = "over"; 
                restartBtn.style.display = "block"; 
            }
            return false; 
        }
        return o.x + o.width > -100; 
    });

    coffees = coffees.filter(c => {
        if (collide(player, c)) { 
            if (player.hp < 3) player.hp++;
            return false; 
        }
        return c.x + c.width > 0;
    });
    
    frame++;
}

function drawUI() {
    const maxDist = bg.width - canvas.width;
    const currentDist = Math.abs(bg.x); 
    let progress = currentDist / maxDist;
    if (progress > 1) progress = 1;

    ctx.fillStyle = "#555";
    if(ctx.roundRect) {
        ctx.roundRect(250, 20, 300, 12, 6); ctx.fill();
        ctx.fillStyle = "#00FFAA"; ctx.beginPath();
        ctx.roundRect(250, 20, 300 * progress, 12, 6); ctx.fill();
    } else {
        ctx.fillRect(250, 20, 300, 12);
        ctx.fillStyle = "#00FFAA"; ctx.fillRect(250, 20, 300 * progress, 12);
    }

    for (let i = 0; i < 3; i++) { 
        if (i < player.hp) {
            drawImageAuto(coffeeImg, 10 + i * 30, 40, 20, 20, "#EBC15A");
        } 
    }
}

function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawImageAuto(bgImg, bg.x, 0, bg.width, bg.height, "#444");
    
    ctx.fillStyle = "#666"; ctx.fillRect(0, 260, canvas.width, 5);
    
    obstacles.forEach(o => {
        ctx.save(); 
        ctx.translate(o.x + o.width / 2, o.y + o.height / 2);
        ctx.rotate(o.angle);
        
        if (o.img && o.img.complete && o.img.naturalWidth > 0) {
            ctx.drawImage(o.img, -o.width / 2, -o.height / 2, o.width, o.height);
        } else {
            ctx.fillStyle = "#FF5252";
            ctx.fillRect(-o.width / 2, -o.height / 2, o.width, o.height);
        }
        ctx.restore(); 
    });
    
    coffees.forEach(c => {
        drawImageAuto(coffeeImg, c.x, c.y, c.width, c.height, "#EBC15A");
    });
    
    if (gameState === "play") drawUI();
    
    if (gameState === "over") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "red"; 
        ctx.font = "bold 40px 'NeoDonggeunmo'";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2); 
    }
    if (gameState === "clear") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "yellow"; 
        ctx.font = "bold 40px 'NeoDonggeunmo'";
        ctx.textAlign = "center";
        ctx.fillText("GAME CLEAR!", canvas.width/2, canvas.height/2); 
    }
}

function loop() { 
    updateGame(); 
    drawGame(); 
    requestAnimationFrame(loop); 
}
loop();

restartBtn.onclick = () => { location.reload(); };
clearBtn.onclick = () => { location.href = "wish.html"; };

</script>

</body>
</html>