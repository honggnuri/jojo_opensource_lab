<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Runner Game - Full Screen</title>

<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* 스크롤 방지 */
        background: #222;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* 게임 컨테이너: 내부는 800x300으로 고정하고 CSS/JS로 확대합니다 */
    #game-container {
        position: relative;
        width: 800px;  /* 게임 내부 로직용 너비 */
        height: 300px; /* 게임 내부 로직용 높이 */
        background: #333;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0,0,0,0.5); /* 외곽선 효과 */
        /* 중앙 정렬을 위한 설정은 JS resize 함수에서 제어합니다 */
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    #player-gif {
        position: absolute;
        z-index: 10;
        width: 40px;
        height: 40px;
        top: 0;
        left: 0;
        will-change: transform;
        display: none;
    }

    .ui-btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 30px;
        background: #00c896;
        border: none;
        border-radius: 12px;
        color: #000;
        font-size: 22px;
        font-weight: bold;
        cursor: pointer;
        display: none;
        z-index: 99;
    }

    #restartBtn { top: 55%; }
    #clearBtn { 
        top: 65%;
        background: #ffe36e; 
    }
</style>
</head>
<body>

<div id="game-container">
    <img id="player-gif" src="src/game/cha.gif" alt="Player">

    <button id="restartBtn" class="ui-btn">다시 시작</button>
    <button id="clearBtn" class="ui-btn">종강이다!</button>

    <canvas id="game" width="800" height="300"></canvas>
</div>

<script>
const container = document.getElementById("game-container");
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const playerEl = document.getElementById("player-gif");
let isMobile = ('ontouchstart' in window);

// === [1. 화면 크기 자동 조절 로직 추가] ===
function resizeGame() {
    const gameWidth = 800;
    const gameHeight = 300;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // 가로/세로 비율 중 더 작은 쪽에 맞춰서 확대 비율 계산 (화면 꽉 차게)
    const scaleX = windowWidth / gameWidth;
    const scaleY = windowHeight / gameHeight;
    const scale = Math.min(scaleX, scaleY);

    // 스케일 적용
    container.style.transform = `scale(${scale})`;
    
    // 스케일 후 화면 중앙에 위치하도록 마진이나 위치 조정이 필요할 수 있음
    // 여기서는 transform으로 크기만 조절하고 flexbox가 중앙 정렬 담당
}

// 창 크기가 바뀔 때마다 실행
window.addEventListener('resize', resizeGame);
resizeGame(); // 초기 실행


// === [게임 로직 설정] ===
ctx.imageSmoothingEnabled = false;

if (!ctx.roundRect) {
    ctx.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
    };
}

let gameState = "play";
const restartBtn = document.getElementById("restartBtn");
const clearBtn = document.getElementById("clearBtn");

/* 이미지 설정 */
let coffeeImg = new Image(); coffeeImg.src = "src/game/coffee.png"; 
let bgImg = new Image(); bgImg.src = "src/game/bg.png"; 

const obstacleSources = [
    "src/game/obstacle1.png", 
    "src/game/obstacle2.png", 
    "src/game/obstacle3.png" 
];
const obstacleImages = obstacleSources.map(src => {
    const img = new Image();
    img.src = src;
    return img;
});

function drawImageAuto(img, x, y, w, h, fallbackColor) {
    if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, w, h);
    } else {
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(x, y, w, h);
    }
}

let player, bg, obstacles, coffees;
let frame, playerDistance, nextPatternDistance;

const obstacleTypes = [
    { width: 40, height: 40 },
    { width: 40, height: 40 },
    { width: 40, height: 40 }
];
const obstacleHeights = [260, 210];

function initGame() {
    player = {
        x: 80,
        y: 200,
        width: 60, 
        height: 60,
        vy: 0,
        gravity: 0.7,
        jumpPower: -14, 
        jumpCount: 0,
        speed: isMobile ? 13 : 6, 
        hp: 3 
    };
    bg = { x: 0, width: 8700, height: 300 };
    
    obstacles = [];
    coffees = [];
    frame = 0;
    playerDistance = 0;
    nextPatternDistance = 500;
    
    playerEl.style.display = "block";
    gameState = "play";
    restartBtn.style.display = "none";
    clearBtn.style.display = "none";
}
initGame();

function doJump() {
    if (gameState !== "play") return;
    if (player.jumpCount < 2) {
        player.vy = player.jumpPower;
        player.jumpCount++;
    }
}

// 이벤트 리스너 (document 전체에 걸어서 확대되어도 터치 잘 먹히게 수정)
document.body.addEventListener("touchstart", e => { 
    e.preventDefault(); 
    doJump(); 
}, { passive: false });

document.body.addEventListener("mousedown", doJump);
window.addEventListener("keydown", e => { 
    if (e.code === "Space") doJump(); 
});


function spawnObstacle(offset = 0, h = "random") {
    const t = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    let yBase = h === "random" ? obstacleHeights[Math.floor(Math.random() * obstacleHeights.length)] : h;
    
    const randomImg = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];

    obstacles.push({ 
        x: canvas.width + offset + 50, 
        y: yBase - t.height, 
        width: t.width, 
        height: t.height,
        img: randomImg 
    });
}

function spawnPattern() {
    const p = Math.floor(Math.random() * 4);
    if (p === 0) spawnObstacle(0, "random");
    if (p === 1) { spawnObstacle(0, 260); spawnObstacle(150, 260); }
    if (p === 2) spawnObstacle(0, 210);
    if (p === 3) { spawnObstacle(0, 260); spawnObstacle(200, 210); }
    
    nextPatternDistance = playerDistance + 550 + Math.random() * 300;
}

function spawnCoffee() {
    coffees.push({ 
        x: canvas.width + 50, 
        y: 150, 
        width: 40, 
        height: 58
    });
}

function collide(player, target) {
    const marginX = 15; 
    const marginY = 10; 

    const pLeft = player.x + marginX;
    const pRight = player.x + player.width - marginX;
    const pTop = player.y + marginY;
    const pBottom = player.y + player.height - marginY;

    const tLeft = target.x;
    const tRight = target.x + target.width;
    const tTop = target.y;
    const tBottom = target.y + target.height;

    return (
        pLeft < tRight &&
        pRight > tLeft &&
        pTop < tBottom &&
        pBottom > tTop
    );
}

// === [2. 수정된 업데이트 로직 (엔딩 연출 포함)] ===
function updateGame() {
    if (gameState !== "play") return;

    // 배경 끝 도달 확인
    let isEndingPhase = (bg.x + bg.width <= canvas.width);

    if (!isEndingPhase) {
        // [일반 주행]
        bg.x -= player.speed * 0.7;
        obstacles.forEach(o => o.x -= player.speed);
        coffees.forEach(c => c.x -= player.speed);

        playerDistance += player.speed;
        if (playerDistance >= nextPatternDistance) spawnPattern();
        if (frame % 400 === 0) spawnCoffee();
    } else {
        // [엔딩 연출]: 배경 멈춤, 캐릭터 앞으로 이동
        player.x += player.speed;
        
        // 캐릭터가 화면 중앙에 오면 클리어
        if (player.x >= (canvas.width / 2) - (player.width / 2)) {
            gameState = "clear";
            clearBtn.style.display = "block";
            return;
        }
    }

    // [공통 물리 적용]
    player.vy += player.gravity;
    player.y += player.vy;
    if (player.y >= 260 - player.height) {
        player.y = 260 - player.height;
        player.vy = 0;
        player.jumpCount = 0;
    }
    
    playerEl.style.transform = `translate(${player.x}px, ${player.y}px)`;
    playerEl.style.width = player.width + "px";
    playerEl.style.height = player.height + "px";

    // 충돌 체크
    obstacles = obstacles.filter(o => {
        if (collide(player, o)) {
            player.hp--;
            if (player.hp <= 0) { 
                gameState = "over"; 
                restartBtn.style.display = "block";
            }
            return false; 
        }
        return o.x + o.width > 0;
    });

    coffees = coffees.filter(c => {
        if (collide(player, c)) { 
            if (player.hp < 3) player.hp++;
            return false; 
        }
        return c.x + c.width > 0;
    });
    
    frame++;
}

function drawUI() {
    const maxDist = bg.width - canvas.width;
    const currentDist = Math.abs(bg.x); 
    let progress = currentDist / maxDist;
    if (progress > 1) progress = 1;

    ctx.fillStyle = "#555";
    if(ctx.roundRect) {
        ctx.roundRect(250, 20, 300, 12, 6); ctx.fill();
        ctx.fillStyle = "#00FFAA"; ctx.beginPath();
        ctx.roundRect(250, 20, 300 * progress, 12, 6); ctx.fill();
    } else {
        ctx.fillRect(250, 20, 300, 12);
        ctx.fillStyle = "#00FFAA"; ctx.fillRect(250, 20, 300 * progress, 12);
    }

    for (let i = 0; i < 3; i++) { 
        if (i < player.hp) {
            drawImageAuto(coffeeImg, 10 + i * 30, 40, 20, 20, "#EBC15A");
        } 
    }
}

function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawImageAuto(bgImg, bg.x, 0, bg.width, bg.height, "#444");
    
    ctx.fillStyle = "#666"; ctx.fillRect(0, 260, canvas.width, 5);
    
    obstacles.forEach(o => {
        drawImageAuto(o.img, o.x, o.y, o.width, o.height, "#FF5252");
    });
    
    coffees.forEach(c => {
        drawImageAuto(coffeeImg, c.x, c.y, c.width, c.height, "#EBC15A");
    });
    
    if (gameState === "play") drawUI();
    
    if (gameState === "over") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "red"; 
        ctx.font = "bold 40px Arial"; 
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2); 
    }
    if (gameState === "clear") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "yellow"; 
        ctx.font = "bold 40px Arial"; 
        ctx.textAlign = "center";
        ctx.fillText("GAME CLEAR!", canvas.width/2, canvas.height/2); 
    }
}

function loop() { 
    updateGame(); 
    drawGame(); 
    requestAnimationFrame(loop); 
}
loop();

restartBtn.onclick = () => { location.reload(); };
clearBtn.onclick = () => { location.href = "wish.html"; };
</script>

</body>
</html>