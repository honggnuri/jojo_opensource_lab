<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Runner Game</title>

<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }

    #game-container {
        position: relative;
        width: 800px;
        height: 300px;
        background: #333;
        overflow: hidden;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    /* 플레이어 GIF */
    #player-gif {
        position: absolute;
        z-index: 10;
        width: 40px;
        height: 40px;
        top: 0;
        left: 0;
        will-change: transform;
        display: none;
    }

    .ui-btn {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 30px;
        background: #00c896;
        border: none;
        border-radius: 12px;
        color: #000;
        font-size: 22px;
        font-weight: bold;
        cursor: pointer;
        display: none;
        z-index: 99;
    }

    #restartBtn { top: 55%; }
    #clearBtn { 
        top: 65%;
        background: #ffe36e; 
    }
</style>
</head>
<body>

<div id="game-container">
    <img id="player-gif" src="src/game/cha.gif" alt="Player">

    <button id="restartBtn" class="ui-btn">다시 시작</button>
    <button id="clearBtn" class="ui-btn">종강이다!</button>

    <canvas id="game" width="800" height="300"></canvas>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const playerEl = document.getElementById("player-gif");
let isMobile = ('ontouchstart' in window);

ctx.imageSmoothingEnabled = false;

if (!ctx.roundRect) {
    ctx.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
    };
}

let gameState = "play";
const restartBtn = document.getElementById("restartBtn");
const clearBtn = document.getElementById("clearBtn");

/* 이미지 설정 */
let coffeeImg = new Image(); coffeeImg.src = "src/game/coffee.png"; 
let bgImg = new Image(); bgImg.src = "src/game/bg.png"; 

// 장애물 이미지 배열
const obstacleSources = [
    "src/game/obstacle1.png", 
    "src/game/obstacle2.png", 
    "src/game/obstacle3.png" 
];
const obstacleImages = obstacleSources.map(src => {
    const img = new Image();
    img.src = src;
    return img;
});

function drawImageAuto(img, x, y, w, h, fallbackColor) {
    if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, w, h);
    } else {
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(x, y, w, h);
    }
}

let player, bg, obstacles, coffees;
let frame, playerDistance, nextPatternDistance;

const obstacleTypes = [
    { width: 40, height: 40 },
    { width: 40, height: 40 },
    { width: 40, height: 40 }
];
const obstacleHeights = [260, 210];

function initGame() {
    player = {
        x: 80,
        y: 200,
        width: 60, 
        height: 60,
        vy: 0,
        gravity: 0.7,
        jumpPower: -14, 
        jumpCount: 0,
        speed: isMobile ? 13 : 6, 
        hp: 3 // [설정] 초기 목숨 3개
    };
    bg = { x: 0, width: 8700, height: 300 };
    
    obstacles = [];
    coffees = [];
    frame = 0;
    playerDistance = 0;
    nextPatternDistance = 500;
    
    playerEl.style.display = "block";
    gameState = "play";
    restartBtn.style.display = "none";
    clearBtn.style.display = "none";
}
initGame();

function doJump() {
    if (gameState !== "play") return;
    if (player.jumpCount < 2) {
        player.vy = player.jumpPower;
        player.jumpCount++;
    }
}

if (isMobile) {
    document.getElementById("game-container").addEventListener("touchstart", e => { 
        e.preventDefault(); 
        doJump(); 
    }, { passive: false });
} else {
    document.getElementById("game-container").addEventListener("mousedown", doJump);
    window.addEventListener("keydown", e => { 
        if (e.code === "Space") doJump(); 
    });
}

function spawnObstacle(offset = 0, h = "random") {
    const t = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    let yBase = h === "random" ? obstacleHeights[Math.floor(Math.random() * obstacleHeights.length)] : h;
    
    const randomImg = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];

    obstacles.push({ 
        x: canvas.width + offset + 50, 
        y: yBase - t.height, 
        width: t.width, 
        height: t.height,
        img: randomImg 
    });
}

function spawnPattern() {
    const p = Math.floor(Math.random() * 4);
    if (p === 0) spawnObstacle(0, "random");
    if (p === 1) { spawnObstacle(0, 260); spawnObstacle(150, 260); }
    if (p === 2) spawnObstacle(0, 210);
    if (p === 3) { spawnObstacle(0, 260); spawnObstacle(200, 210); }
    
    nextPatternDistance = playerDistance + 550 + Math.random() * 300;
}

function spawnCoffee() {
    coffees.push({ 
        x: canvas.width + 50, 
        y: 150, 
        width: 40, 
        height: 58
    });
}

function collide(player, target) {
    const marginX = 15; 
    const marginY = 10; 

    const pLeft = player.x + marginX;
    const pRight = player.x + player.width - marginX;
    const pTop = player.y + marginY;
    const pBottom = player.y + player.height - marginY;

    const tLeft = target.x;
    const tRight = target.x + target.width;
    const tTop = target.y;
    const tBottom = target.y + target.height;

    return (
        pLeft < tRight &&
        pRight > tLeft &&
        pTop < tBottom &&
        pBottom > tTop
    );
}

function updateGame() {
    if (gameState !== "play") return;

    bg.x -= player.speed * 0.7;

    if (bg.x + bg.width <= canvas.width) {
        gameState = "clear";
        clearBtn.style.display = "block";
        return;
    }

    player.vy += player.gravity;
    player.y += player.vy;
    if (player.y >= 260 - player.height) {
        player.y = 260 - player.height;
        player.vy = 0;
        player.jumpCount = 0;
    }
    
    playerEl.style.transform = `translate(${player.x}px, ${player.y}px)`;
    playerEl.style.width = player.width + "px";
    playerEl.style.height = player.height + "px";

    obstacles.forEach(o => o.x -= player.speed);
    obstacles = obstacles.filter(o => {
        if (collide(player, o)) {
            player.hp--;
            if (player.hp <= 0) { 
                gameState = "over"; 
                restartBtn.style.display = "block";
            }
            return false; 
        }
        return o.x + o.width > 0;
    });

    coffees.forEach(c => c.x -= player.speed);
    coffees = coffees.filter(c => {
        if (collide(player, c)) { 
            if (player.hp < 3) player.hp++; // [수정] 최대 체력 3으로 제한
            return false; 
        }
        return c.x + c.width > 0;
    });

    playerDistance += player.speed;
    if (playerDistance >= nextPatternDistance) spawnPattern();
    
    if (frame % 400 === 0) spawnCoffee();
    
    frame++;
}

function drawUI() {
    const maxDist = bg.width - canvas.width;
    const currentDist = Math.abs(bg.x); 
    let progress = currentDist / maxDist;
    if (progress > 1) progress = 1;

    ctx.fillStyle = "#555";
    if(ctx.roundRect) {
        ctx.roundRect(250, 20, 300, 12, 6); ctx.fill();
        ctx.fillStyle = "#00FFAA"; ctx.beginPath();
        ctx.roundRect(250, 20, 300 * progress, 12, 6); ctx.fill();
    } else {
        ctx.fillRect(250, 20, 300, 12);
        ctx.fillStyle = "#00FFAA"; ctx.fillRect(250, 20, 300 * progress, 12);
    }

    // [수정] 목숨 그리기
    // 1. 반복문을 3회(목숨 3개)까지만 수행
    // 2. else 문을 삭제하여, 목숨이 깎인 자리에는 아무것도 그리지 않음
    for (let i = 0; i < 3; i++) { 
        if (i < player.hp) {
            drawImageAuto(coffeeImg, 10 + i * 30, 40, 20, 20, "#EBC15A");
        } 
        // else { ... } <-- 이 부분이 삭제됨 (회색 사각형 제거)
    }
}

function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawImageAuto(bgImg, bg.x, 0, bg.width, bg.height, "#444");
    
    ctx.fillStyle = "#666"; ctx.fillRect(0, 260, canvas.width, 5);
    
    obstacles.forEach(o => {
        drawImageAuto(o.img, o.x, o.y, o.width, o.height, "#FF5252");
    });
    
    coffees.forEach(c => {
        drawImageAuto(coffeeImg, c.x, c.y, c.width, c.height, "#EBC15A");
    });
    
    if (gameState === "play") drawUI();
    if (gameState === "over") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "red"; 
        ctx.font = "bold 40px Arial"; 
        ctx.fillText("GAME OVER", canvas.width/2 - 120, canvas.height/2); 
    }
    if (gameState === "clear") { 
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "yellow"; 
        ctx.font = "bold 40px Arial"; 
        ctx.fillText("GAME CLEAR!", canvas.width/2 - 130, canvas.height/2); 
    }
}

function loop() { 
    updateGame(); 
    drawGame(); 
    requestAnimationFrame(loop); 
}
loop();

restartBtn.onclick = () => { location.reload(); };
clearBtn.onclick = () => { location.href = "wish.html"; };
</script>

</body>
</html>